#' Request metadata for all datasets in specified workspace
#'
#' @param workspace Name of the workspace containing datasets
#' @param powerbi_token AzureAuth token object generated by `get_powerbi_token()`
#'
#' @return DataFrame containing the names, GUIDs, and descriptions for all datasets in workspace
#' @export
list_datasets <- function(workspace, powerbi_token) {
  workspace_metadata <- list_workspaces(powerbi_token)
  if (!(workspace %in% workspace_metadata$Workspace)) {
    stop("No workspace called: ", workspace, " in tenant!", call. = FALSE)
  }

  base_url <- "https://api.powerbi.com/v1.0/myorg/groups/"
  workspace_id <- workspace_metadata[workspace_metadata$Workspace == workspace,]$WorkspaceId
  workspace_request <-  httr::GET(url = paste0(base_url, workspace_id, "/datasets"),
                                  config = get_auth_header(powerbi_token),
                                  httr::content_type_json())

  if (workspace_request$status_code != 200) {
    stop("API request returned status code: ", workspace_request$status_code, "!",
         call. = TRUE)
  }

  metadata_content <- httr::content(workspace_request)$value

  content_to_dataframe <- purrr::map_dfr(metadata_content, \(metadata){
    do.call(data.frame, purrr::keep(metadata, \(x){length(x) > 0}))
  })
  content_to_dataframe$Workspace <- workspace
  content_to_dataframe$WorkspaceId <- workspace_id

  content_to_dataframe <- content_to_dataframe[,c("Workspace", "WorkspaceId", "name", "id", "configuredBy")]
  names(content_to_dataframe) <- c("Workspace", "WorkspaceId", "Dataset", "DatasetId", "DatasetOwner")
  content_to_dataframe
}

#' Download a specified dataset table into R using either the XMLA or REST API
#' endpoints. This is a convenience wrapper around the `execute_xmla_query()`
#' and `execute_rest_query()` functions.
#'
#' @param workspace Name of the workspace containing dataflow
#' @param dataset Name of the dataset containing table
#' @param table Name of the table to download
#' @param method The API to use for downloading the table. Valid values are "XMLA" (the default) and "REST"
#' @param powerbi_token AzureAuth token object generated by `get_powerbi_token()`
#'
#' @return DataFrame containing downloaded table
#' @export
get_dataset_table <- function(workspace, dataset, table,
                              method = "XMLA",
                              powerbi_token = get_powerbi_token(application_id = "23d8f6bd-1eb0-4cc2-a08c-7bf525c67bcd")) {
  query <- paste0("EVALUATE(", table, ")")
  if (method == "XMLA") {
    table_query <- execute_xmla_query(workspace, dataset, query, powerbi_token)
  } else if (method == "REST") {
    table_query <- execute_rest_query(workspace, dataset, query, powerbi_token)
  } else {
    stop("Invalid method: ", method, "! Valid values are \"XMLA\" or \"REST\".",
         call. = FALSE)
  }
  names(table_query) <- gsub(paste0(table, "\\[|\\]"), "", names(table_query))
  table_query
}

#' Execute a DAX query against a specified PowerBI Dataset using the REST API
#' endpoint.
#'
#' @param workspace Name of the workspace containing dataflow
#' @param dataset Name of the dataset to execute query against
#' @param query DAX query to execute
#' @param powerbi_token AzureAuth token object generated by `get_powerbi_token()`
#'
#' @return DataFrame containing results of query
#' @export
execute_rest_query <- function(workspace, dataset, query, powerbi_token) {
  dataset_metadata <- list_datasets(workspace, powerbi_token)
  if (!(dataset %in% dataset_metadata$Dataset)) {
    stop("No dataset called: ", dataset, "in workspace: ", workspace, "!", call. = FALSE)
  }

  target_dataset <- dataset_metadata[dataset_metadata$Dataset == dataset, ]
  dataset_id <- target_dataset$DatasetId

  query_url <- paste0("https://api.powerbi.com/v1.0/myorg/datasets/", dataset_id, "/executeQueries")

  rest_query <- httr::POST(url = query_url,
                          body = construct_rest_query(query),
                          config = get_auth_header(powerbi_token),
                          httr::content_type_json())

  query_content <- httr::content(rest_query)

  if ("error" %in% names(query_content)) {
    stop("Query returned error: ", query_content$error$pbi.error$details[[1]]$detail$value,
         call. = FALSE)
  }

  if (("error" %in% names(query_content$results[[1]]))) {
    error_code <- query_content$results[[1]]$error$code
    if (error_code == "DaxByteCountNotSupported") {
      stop("The query result is too large for the REST API! Try the XMLA API instead.\n",
           "See: https://learn.microsoft.com/en-us/rest/api/power-bi/datasets/execute-queries#limitations",
           call. = FALSE)
    }
  }

  query_content$results[[1]]$tables[[1]]$rows |>
    purrr::map_dfr(~purrr::modify_if(.x, is.null, ~as.numeric(NA)))
}


#' Execute a DAX query against a specified PowerBI Dataset using the XMLA API
#' endpoint.
#'
#' @param workspace Name of the workspace containing dataflow
#' @param dataset Name of the dataset to execute query against
#' @param query DAX query to execute
#' @param powerbi_token AzureAuth token object generated by `get_powerbi_token()`
#'
#' @return DataFrame containing results of query
#' @export
execute_xmla_query <- function(workspace, dataset, query, powerbi_token) {
  workspace_metadata <- list_workspaces(powerbi_token)
  target_workspace <- workspace_metadata[workspace_metadata$Workspace == workspace, ]

  capacity_id <- target_workspace$CapacityID
  capacity_uri <- target_workspace$CapacityUri
  workspace_id <- target_workspace$WorkspaceId

  capacity_region <- gsub("(pbidedicated://)(.*).pbidedicated.windows.net(.*)", "\\2", capacity_uri)
  xmla_server <- get_xmla_server(capacity_region, capacity_id, powerbi_token)
  xmla_token <- get_xmla_token(capacity_id, workspace_id, powerbi_token)

  xmla_request <-
    httr::POST(
      url = paste0("https://", xmla_server$clusterFQDN, "/webapi/xmla"),
      config = httr::add_headers(Authorization = paste("MwcToken", xmla_token)),
      body = construct_xmla_query(dataset, query),
      httr::add_headers(.headers = c(
        "x-ms-xmlaserver" = xmla_server$coreServerName,
        "x-ms-xmlacaps-negotiation-flags" = "0,0,0,1,1",
        "Content-Type" = "text/xml",
        "x-ms-request-registration-id" = uuid::UUIDgenerate(),
        "x-ms-xmlaclienttraits" = 1,
        "x-ms-xmladedicatedconnection" = 0,
        "x-ms-accepts-continuations" = 1,
        "x-ms-round-trip-id" = 0
      ))
    )
  request_results <- httr::content(xmla_request, encoding = "UTF-8")
  rowset_to_df(request_results)
}
